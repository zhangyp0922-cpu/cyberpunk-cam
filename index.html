<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyberpunk Tactical Scanner V2</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        
        /* 视频层 */
        #video-feed {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1;
            filter: contrast(1.1) brightness(1.2) sepia(0.2) hue-rotate(180deg) saturate(1.5); 
            opacity: 0.8;
        }

        .backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 0;
        }

        /* Canvas层 */
        #detection-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2;
            pointer-events: none;
        }

        /* UI层 */
        #ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 3;
            pointer-events: none;
        }

        .hud-text { color: rgba(0, 255, 204, 0.8); text-shadow: 0 0 5px #00ffcc; font-size: 10px; position: absolute; }
        .center-cross {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40px; height: 40px;
        }
        .center-cross::before, .center-cross::after {
            content: ''; position: absolute; background: rgba(255, 255, 255, 0.5);
        }
        .center-cross::before { top: 19px; left: 0; width: 40px; height: 2px; }
        .center-cross::after { top: 0; left: 19px; width: 2px; height: 40px; }

        .loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            background: #000; display: flex; justify-content: center; align-items: center;
            flex-direction: column; color: #00ffcc;
            transition: opacity 0.5s;
        }
        .blink { animation: blinker 1s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }
    </style>
</head>
<body>
    <div class="backdrop"></div>
    <video id="video-feed" autoplay playsinline muted></video>
    <canvas id="detection-canvas"></canvas>

    <div id="loading-overlay" class="loading-overlay">
        <div style="font-size: 24px; font-weight: bold; border: 2px solid #00ffcc; padding: 10px;">SYSTEM BOOT</div>
        <div class="blink" style="margin-top: 20px;">LOADING NEURAL NET...</div>
    </div>

    <div id="ui-layer">
        <div class="center-cross"></div>
        <div class="hud-text" style="top: 10px; left: 10px;">CAM_01: ONLINE</div>
        <div class="hud-text" style="top: 10px; right: 10px;" id="fps-counter">FPS: 00</div>
        <div class="hud-text" style="bottom: 10px; left: 10px;">MODE: TACTICAL_SCAN</div>
        <div style="position: absolute; bottom: 40px; left: 10px; font-size: 8px; color: rgba(0,255,204,0.4); line-height: 10px; width: 200px; word-break: break-all;">
            0XAF32 0XBB91 DATA_PACKET_STREAM_SYNC_V2.0_ENABLED_ROOT_ACCESS_GRANTED
        </div>
    </div>

    <script>
        const video = document.getElementById('video-feed');
        const canvas = document.getElementById('detection-canvas');
        const ctx = canvas.getContext('2d');
        const loadingOverlay = document.getElementById('loading-overlay');
        const fpsCounter = document.getElementById('fps-counter');

        let model = null;
        let isDetecting = false;
        let lastTime = 0;

        // 颜色配置
        const COLORS = {
            person:     { r: 255, g: 50,  b: 50,  hex: '#FF3232' }, // 红
            cell_phone: { r: 0,   g: 255, b: 255, hex: '#00FFFF' }, // 青
            laptop:     { r: 0,   g: 255, b: 255, hex: '#00FFFF' },
            keyboard:   { r: 0,   g: 255, b: 255, hex: '#00FFFF' },
            mouse:      { r: 0,   g: 255, b: 255, hex: '#00FFFF' },
            cup:        { r: 255, g: 200, b: 0,   hex: '#FFC800' }, // 黄
            default:    { r: 255, g: 255, b: 255, hex: '#FFFFFF' }
        };

        function getColor(label) {
            const key = label.replace(' ', '_');
            return COLORS[key] || COLORS.default;
        }

        async function init() {
            try {
                // 加载轻量级模型
                model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
                startCamera();
            } catch (error) {
                alert("AI 模型加载失败: " + error);
            }
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: { exact: "environment" },
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 } 
                    },
                    audio: false
                });
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    loadingOverlay.style.opacity = 0;
                    setTimeout(() => loadingOverlay.remove(), 500);
                    isDetecting = true;
                    // 【关键修复】使用 requestAnimationFrame 启动，确保传入时间戳
                    requestAnimationFrame(predictLoop);
                };
            } catch (err) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    video.srcObject = stream;
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        loadingOverlay.style.opacity = 0;
                        setTimeout(() => loadingOverlay.remove(), 500);
                        isDetecting = true;
                        requestAnimationFrame(predictLoop);
                    }
                } catch(e) {
                    alert("无法调用摄像头");
                }
            }
        }

        function predictLoop(timestamp) {
            if (!isDetecting || !model || video.readyState !== 4) {
                requestAnimationFrame(predictLoop);
                return;
            }

            // 【关键修复】确保 timestamp 存在
            if (!timestamp) timestamp = performance.now();

            if (timestamp) {
                const fps = Math.round(1000 / (timestamp - lastTime));
                if (timestamp % 10 === 0) fpsCounter.innerText = `FPS: ${fps}`;
                lastTime = timestamp;
            }

            model.detect(video).then(predictions => {
                drawCyberpunkHUD(predictions, timestamp);
                requestAnimationFrame(predictLoop);
            });
        }

        function drawCyberpunkHUD(predictions, time) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();

            predictions.forEach(prediction => {
                if (prediction.score < 0.60) return;

                const [x, y, w, h] = prediction.bbox;
                const label = prediction.class.toUpperCase();
                const colorObj = getColor(prediction.class);
                const colorHex = colorObj.hex;
                const score = Math.floor(prediction.score * 100);

                // --- 1. 绘制战术包角 ---
                ctx.strokeStyle = colorHex;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = colorHex;

                const lineLen = Math.min(w, h) * 0.25;

                ctx.beginPath();
                // 左上
                ctx.moveTo(x, y + lineLen); ctx.lineTo(x, y); ctx.lineTo(x + lineLen, y);
                // 右上
                ctx.moveTo(x + w - lineLen, y); ctx.lineTo(x + w, y); ctx.lineTo(x + w, y + lineLen);
                // 右下
                ctx.moveTo(x + w, y + h - lineLen); ctx.lineTo(x + w, y + h); ctx.lineTo(x + w - lineLen, y + h);
                // 左下
                ctx.moveTo(x + lineLen, y + h); ctx.lineTo(x, y + h); ctx.lineTo(x, y + h - lineLen);
                ctx.stroke();

                // --- 2. 绘制内部扫描光束 (关键修复与增强) ---
                // 使用 save/restore 和 clip 确保光束只在框内
                ctx.save(); 
                ctx.beginPath();
                ctx.rect(x, y, w, h);
                ctx.clip(); // 裁剪区域：之后的绘图只在这个矩形内显示

                // 计算光束位置 (速度变慢一点看起来更高级)
                const scanSpeed = 0.15; 
                const scanY = y + (time * scanSpeed) % h;
                
                // 绘制光束
                ctx.beginPath();
                ctx.moveTo(x, scanY);
                ctx.lineTo(x + w, scanY);
                ctx.strokeStyle = `rgba(${colorObj.r}, ${colorObj.g}, ${colorObj.b}, 1)`; // 不透明度调高
                ctx.lineWidth = 4; // 线条加粗
                ctx.shadowColor = "white"; // 增加白色高光
                ctx.shadowBlur = 10;
                ctx.stroke();

                // 绘制淡淡的背景填充
                ctx.fillStyle = `rgba(${colorObj.r}, ${colorObj.g}, ${colorObj.b}, 0.15)`;
                ctx.fillRect(x, y, w, h);
                
                ctx.restore(); // 恢复画布状态，防止 clip 影响后续绘图

                // --- 3. 标签与引线 ---
                ctx.shadowBlur = 0;
                const labelX = x + w + 15;
                const labelY = y + 10; // 稍微下移
                
                // 折线
                ctx.beginPath();
                ctx.moveTo(x + w, y);
                ctx.lineTo(labelX - 5, labelY - 5);
                ctx.lineTo(labelX + 90, labelY - 5);
                ctx.strokeStyle = colorHex;
                ctx.lineWidth = 1;
                ctx.stroke();

                // 标签背景 (让文字更清晰)
                // ctx.fillStyle = "rgba(0,0,0,0.5)";
                // ctx.fillRect(labelX, labelY - 20, 100, 35);

                // 文字
                ctx.fillStyle = colorHex;
                ctx.font = 'bold 16px "Courier New"';
                ctx.fillText(label, labelX, labelY - 8);
                
                ctx.fillStyle = "rgba(255,255,255,0.8)";
                ctx.font = '12px "Courier New"';
                ctx.fillText(`ID_${score} [LOCKED]`, labelX, labelY + 8);
            });
        }

        function drawGrid() {
            ctx.strokeStyle = "rgba(0, 255, 204, 0.08)";
            ctx.lineWidth = 1;
            ctx.shadowBlur = 0;
            
            const gridSize = 80;
            const w = canvas.width;
            const h = canvas.height;

            ctx.beginPath();
            for(let x=0; x<=w; x+=gridSize) {
                ctx.moveTo(x, 0); ctx.lineTo(x, h);
            }
            for(let y=0; y<=h; y+=gridSize) {
                ctx.moveTo(0, y); ctx.lineTo(w, y);
            }
            ctx.stroke();
        }

        init();
    </script>
</body>
</html>
