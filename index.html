<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyberpunk Tactical Scanner</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        
        /* 视频层 */
        #video-feed {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1;
            filter: contrast(1.1) brightness(1.2) sepia(0.2) hue-rotate(180deg) saturate(1.5); 
            /* 上面的滤镜是为了让画面看起来更像电子眼 */
            opacity: 0.8;
        }

        /* 纯黑背景层，防止视频加载前白屏 */
        .backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 0;
        }

        /* Canvas层：绘制高亮和UI */
        #detection-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2;
            pointer-events: none;
        }

        /* 纯装饰UI层 */
        #ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 3;
            pointer-events: none;
        }

        /* 装饰元素 */
        .hud-text { color: rgba(0, 255, 204, 0.8); text-shadow: 0 0 5px #00ffcc; font-size: 10px; position: absolute; }
        .center-cross {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40px; height: 40px;
        }
        .center-cross::before, .center-cross::after {
            content: ''; position: absolute; background: rgba(255, 255, 255, 0.5);
        }
        .center-cross::before { top: 19px; left: 0; width: 40px; height: 2px; }
        .center-cross::after { top: 0; left: 19px; width: 2px; height: 40px; }

        .loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            background: #000; display: flex; justify-content: center; align-items: center;
            flex-direction: column; color: #00ffcc;
            transition: opacity 0.5s;
        }
        .blink { animation: blinker 1s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }
    </style>
</head>
<body>
    <div class="backdrop"></div>
    <video id="video-feed" autoplay playsinline muted></video>
    <canvas id="detection-canvas"></canvas>

    <div id="loading-overlay" class="loading-overlay">
        <div style="font-size: 24px; font-weight: bold; border: 2px solid #00ffcc; padding: 10px;">SYSTEM BOOT</div>
        <div class="blink" style="margin-top: 20px;">LOADING NEURAL NET...</div>
    </div>

    <div id="ui-layer">
        <div class="center-cross"></div>
        <div class="hud-text" style="top: 10px; left: 10px;">CAM_01: ONLINE</div>
        <div class="hud-text" style="top: 10px; right: 10px;" id="fps-counter">FPS: 00</div>
        <div class="hud-text" style="bottom: 10px; left: 10px;">MODE: TACTICAL_SCAN</div>
        <div style="position: absolute; bottom: 40px; left: 10px; font-size: 8px; color: rgba(0,255,204,0.4); line-height: 10px; width: 200px; word-break: break-all;">
            0XAF32 0XBB91 DATA_PACKET_STREAM_SYNC_V2.0_ENABLED_ROOT_ACCESS_GRANTED
        </div>
    </div>

    <script>
        const video = document.getElementById('video-feed');
        const canvas = document.getElementById('detection-canvas');
        const ctx = canvas.getContext('2d');
        const loadingOverlay = document.getElementById('loading-overlay');
        const fpsCounter = document.getElementById('fps-counter');

        let model = null;
        let isDetecting = false;
        let lastTime = 0;

        // --- 颜色配置系统 ---
        // 红色：人类/生物 (高危)
        // 青色：电子设备 (科技)
        // 黄色：其他物体 (常规)
        const COLORS = {
            person:     { r: 255, g: 50,  b: 50,  hex: '#FF3232' }, 
            cell_phone: { r: 0,   g: 255, b: 255, hex: '#00FFFF' },
            laptop:     { r: 0,   g: 255, b: 255, hex: '#00FFFF' },
            tv:         { r: 0,   g: 255, b: 255, hex: '#00FFFF' },
            keyboard:   { r: 0,   g: 255, b: 255, hex: '#00FFFF' },
            mouse:      { r: 0,   g: 255, b: 255, hex: '#00FFFF' },
            default:    { r: 255, g: 200, b: 0,   hex: '#FFC800' }
        };

        function getColor(label) {
            // 将标签标准化（有些模型返回带空格）
            const key = label.replace(' ', '_');
            return COLORS[key] || COLORS.default;
        }

        // --- 初始化 ---
        async function init() {
            try {
                // 加载 COCO-SSD 模型
                model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
                startCamera();
            } catch (error) {
                alert("AI 模型加载失败: " + error);
            }
        }

        // --- 摄像头 ---
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: { exact: "environment" },
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 } 
                    },
                    audio: false
                });
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    loadingOverlay.style.opacity = 0;
                    setTimeout(() => loadingOverlay.remove(), 500);
                    isDetecting = true;
                    predictLoop();
                };
            } catch (err) {
                // 降级处理：如果不让用后置，就用默认
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    video.srcObject = stream;
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        loadingOverlay.style.opacity = 0;
                        setTimeout(() => loadingOverlay.remove(), 500);
                        isDetecting = true;
                        predictLoop();
                    }
                } catch(e) {
                    alert("无法调用摄像头");
                }
            }
        }

        // --- AI 循环 ---
        function predictLoop(timestamp) {
            if (!isDetecting || !model || video.readyState !== 4) {
                requestAnimationFrame(predictLoop);
                return;
            }

            // 计算FPS
            if (timestamp) {
                const fps = Math.round(1000 / (timestamp - lastTime));
                if (timestamp % 10 === 0) fpsCounter.innerText = `FPS: ${fps}`;
                lastTime = timestamp;
            }

            model.detect(video).then(predictions => {
                drawCyberpunkHUD(predictions, timestamp);
                requestAnimationFrame(predictLoop);
            });
        }

        // --- 核心：赛博朋克绘制逻辑 ---
        function drawCyberpunkHUD(predictions, time) {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 绘制全屏网格线（增加科技感背景）
            drawGrid();

            predictions.forEach(prediction => {
                if (prediction.score < 0.60) return; // 过滤低置信度

                const [x, y, w, h] = prediction.bbox;
                const label = prediction.class.toUpperCase();
                const colorObj = getColor(prediction.class);
                const colorHex = colorObj.hex;
                const score = Math.floor(prediction.score * 100);

                // 1. 绘制“战术锁定”包角 (四个L型)
                ctx.strokeStyle = colorHex;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10; // 霓虹光晕
                ctx.shadowColor = colorHex;

                const lineLen = Math.min(w, h) * 0.2; // 角落线的长度

                ctx.beginPath();
                
                // 左上
                ctx.moveTo(x, y + lineLen); ctx.lineTo(x, y); ctx.lineTo(x + lineLen, y);
                // 右上
                ctx.moveTo(x + w - lineLen, y); ctx.lineTo(x + w, y); ctx.lineTo(x + w, y + lineLen);
                // 右下
                ctx.moveTo(x + w, y + h - lineLen); ctx.lineTo(x + w, y + h); ctx.lineTo(x + w - lineLen, y + h);
                // 左下
                ctx.moveTo(x + lineLen, y + h); ctx.lineTo(x, y + h); ctx.lineTo(x, y + h - lineLen);
                
                ctx.stroke();

                // 2. 绘制内部扫描光束 (上下移动)
                // 使用时间戳实现动画
                const scanSpeed = 0.2; 
                const scanY = y + (time * scanSpeed) % h;
                
                ctx.beginPath();
                ctx.moveTo(x, scanY);
                ctx.lineTo(x + w, scanY);
                ctx.lineWidth = 1;
                ctx.strokeStyle = `rgba(${colorObj.r}, ${colorObj.g}, ${colorObj.b}, 0.5)`;
                ctx.stroke();

                // 3. 绘制填充背景 (半透明)
                ctx.fillStyle = `rgba(${colorObj.r}, ${colorObj.g}, ${colorObj.b}, 0.1)`;
                ctx.fillRect(x, y, w, h);

                // 4. 绘制连接引线和标签
                ctx.shadowBlur = 0; // 文字不需要发光太强
                const labelX = x + w + 10;
                const labelY = y;
                
                // 画折线
                ctx.beginPath();
                ctx.moveTo(x + w, y);
                ctx.lineTo(labelX, labelY - 10);
                ctx.lineTo(labelX + 100, labelY - 10); // 标签下划线
                ctx.strokeStyle = colorHex;
                ctx.lineWidth = 1;
                ctx.stroke();

                // 标签文字
                ctx.fillStyle = colorHex;
                ctx.font = 'bold 16px "Courier New"';
                ctx.fillText(`${label}`, labelX, labelY - 15);
                
                ctx.font = '12px "Courier New"';
                ctx.fillStyle = "rgba(255,255,255,0.7)";
                ctx.fillText(`CONF: ${score}%`, labelX, labelY);
                ctx.fillText(`DIST: ${(1000/w).toFixed(1)}m`, labelX, labelY + 12); // 伪造的距离数据
            });
        }

        function drawGrid() {
            // 绘制淡淡的绿色网格，增强空间感
            ctx.strokeStyle = "rgba(0, 255, 204, 0.1)";
            ctx.lineWidth = 1;
            ctx.shadowBlur = 0;
            
            const gridSize = 100;
            const w = canvas.width;
            const h = canvas.height;

            ctx.beginPath();
            for(let x=0; x<=w; x+=gridSize) {
                ctx.moveTo(x, 0); ctx.lineTo(x, h);
            }
            for(let y=0; y<=h; y+=gridSize) {
                ctx.moveTo(0, y); ctx.lineTo(w, y);
            }
            ctx.stroke();
        }

        init();
    </script>
</body>
</html>
